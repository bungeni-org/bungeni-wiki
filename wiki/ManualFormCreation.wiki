#summary Create Form manually and override the built in automatic form generation
#labels zope,sqlalchemy
= Introduction =

For some use cases the autogenerated forms are not sufficient. 



= Details =

depends on what you mean by computed fields.. read only fields on a
form, sure. computed fields in the sense that the value is dynamic
basic on whole object state yes, though the latter would require.

Both of these require actually creating a form, not using the
autogenerated facilities. This is pretty easy.

first there are two tasks here. using the subclassing
alchemist content forms, means you will get autogenerated ui
implemenentation, which sets up form_fields on the view when
published, which is not what you want.  typically you would just use
the corresponding base formlib class or formlib viewlet classes.

the default edit views, are composed of various viewlets, an edit
attribute viewlet is used for an object's attributes, and typically
relations viewlets for other parts. if you want a completely custom
view, you can just replace the entire view, but probably more typical
is just replacing the edit attributes viewlet.

Customize the edit attribute viewlet for a particular class,  i.e. say i want a readonly field on an edit form.
You can prep formlib  by telling it the adapter, so instead of going to
query the component architecture it just uses a
dictionary mapping interface to adapter.

{{{
from alchemist.ui.viewlet import EditFormViewlet
from zope.formlib import form
from zope import schema, interface
from bungeni.core.interfaces import IMyContent

class ContentEditForm( EditFormViewlet ):
   form_fields = form.Fields( interfaces.IMyContent )
   form_fields['name'].for_display= True
   template = NamedTemplate('alchemist.subform')   

    def update(self):
        """
        Called by formlib after __init__ for every page update. This is
        the method you can use to update form fields from your class
        and adapt the custom fields to our object
        """               
        self.adapters = { IMyContent : self.context }        
}}}


The name of the view should be the same as the autogenerated view, and you have to
register it for the class, which will override the default registration
of the autogenerated form.

To get the name of the autogenerated form you may use echo="True" on the db:catalyst declaration and it will log to the stdout all the things that its doing.
{{{
  <db:catalyst
     class=".domain.GroupSittingAttendance"
     descriptor=".descriptor.AttendanceDescriptor"
     interface_module=".interfaces"
     ui_module="bungeni.ui.content"
     echo="True"
    />  
}}}
will produce the output:
{{{
catalyst domain -> GroupSittingAttendance: generated interface bungeni.core.interfaces.IGroupSittingAttendance
catalyst container -> GroupSittingAttendance: generated container bungeni.core.domain.GroupSittingAttendanceContainer
catalyst container -> GroupSittingAttendance: generated container interface bungeni.core.domain.IGroupSittingAttendanceContainer
catalyst ui -> GroupSittingAttendance: generated add view bungeni.ui.content.GroupSittingAttendanceAddForm
catalyst ui -> GroupSittingAttendance: registered GroupSittingAttendanceAddForm for IGroupSittingAttendanceContainer, layer Default, permission zope.Public
catalyst ui -> GroupSittingAttendance: generated edit view bungeni.ui.content.GroupSittingAttendanceEditForm
catalyst ui -> GroupSittingAttendance: registered GroupSittingAttendanceEditForm for IGroupSittingAttendance, layer Default, permission zope.Public
catalyst ui -> GroupSittingAttendance: generated view view bungeni.ui.content.GroupSittingAttendanceDisplayForm
catalyst ui -> GroupSittingAttendance: registered GroupSittingAttendanceDisplayForm for IGroupSittingAttendance, layer Default, permission zope.Public
}}}

The add form is also a bit of special case. Its not a set of
viewlets, just a dynamic form view. i need to do a refactor on it, as
currently tied into the dynamic form proccesing, and you do want the
add behavior it specifies. as temporary work around you can define an
update method, and prevent the default form from dynamically resetting
its form_fields. Set the adapters in the finishConstruction method.

{{{
class MyContentAddForm( content.ContentAddForm ):
    form_fields = form.Fields( IMyCustomFields )

    def update( self ):
         self.status = self.request.get('portal_status_message','')
         form.AddForm.update( self )

    def finishConstruction( self, ob ):
         self.adapters = { IMyCustomFields : ob }
}}}


Any manually created forms need also to be manually registered in zcml.
Note that the add form is registered for the container where you add the contents, whereas the edit form is tied to the interface of the content itself.

{{{
<configure xmlns="http://namespaces.zope.org/zope"
           xmlns:browser="http://namespaces.zope.org/browser" >
  <!-- Add Form -->
   <browser:view
      name="add"
      for="bungeni.core.interfaces.IMyContentContainer"
      class=".forms.MyContentAddForm"              
      permission="zope.View"
      />

    
  <!-- Edit Form -->
    <browser:viewlet
      name="alchemist.attributes.edit"
      manager="alchemist.ui.interfaces.IContentEditManager"
      class=".forms.ContentEditForm"
      for="bungeni.core.interfaces.IMyContent"
      permission="zope.View"
      allowed_interface="zope.formlib.interfaces.ISubPageForm"      
      />
      

</configure>
}}}






>
>  rational:
>
>  for some checks we need to access the parent, e.g. a parliamentary
>  sitting must be in the date range of the parliament, it cannot start
>  before the parliaments start date and must not end after the parliament
>  end date.





first, this really doesn't have anything to do with computed fields.
second when accessing context its important to understand that their
are two different categories of forms with two different contexts, ie.
add form and edit forms. unlike cmf, zope3 isn't required to create a
content stub just to have a form, but that distinction also means we
have two forms for a content that would need to be potentially
modified to handle these constraints.

second, any formlib form can have a custom validator independent of
any schema invariants, as part of the action handler. see zope.formlib
readme for examples.

third, yes you can use a schema invariant and still have access to
context, but thats only meaningful in certain an edit form context.

a parent is accessed via ob.__parent__


>
>  If i check constraints with invariants i can only access the current
>  fields of the form. afaik there is no way to access the parent of the
>  object i am editing (or is there?).
>
>  the computed field must not be editable and should be hidden by default,
>  though in some use cases it would make sense to display it.
>

use a custom form and omit the field or set it to display mode.