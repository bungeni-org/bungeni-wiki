#summary Bungeni design considerations (ZODB/RDBMS)
#labels Phase-Design

= The relationship between the registry and the ZODB in Bungeni =

== Background ==

From the outset, one of the requirements for Bungeni was that a registry
of all parliamentary information should be kept in an RDBMS. Some
questions are raised by this requirement:

  * Should all or some of this information should also be stored in Plone?

  * Should some or all Plone-specific operational data be stored in the RDBMS, and where exactly should the line be drawn between parliamentary and operational information?

  * Besides the storing of data, should the RDBMS additionally contain stored procedures and triggers to implement some of the business rules and constraints of the data, or should Plone ensure data integrity from the outset?

This document is an attempt to delineate the different possible choices,
to describe the trade-offs and issues to be considered, and to describe
and motivate the current design.

In the following document, by Bungeni I mean the Plone product of the
same name, and by registry I mean an RDBMS storing parliamentary data.

== Design goals for the registry ==

The registry should function as integration point for external systems. 

    While Plone can publish its information in various formats such as
    RSS, OAI-PMH, WebDAV and FTP, it isn't accessible via ODBC and
    cannot be queried using SQL. For external applications wishing to
    integrate with Bungeni via relational means, the registry provides
    an integration point.

The scope of the registry and of Bungeni are not the same.

    External systems may use the registry to store data that is not
    relevant to the Plone application. For example, they may store
    checkin/checkout times of staff, rosters of cleaning staff or other
    non-parliamentary groups, etc.

    Therefore it is a requirement that the registry not be constrained
    by the data represented in Plone.

The registry schema should not be determined by ORM requirements.

    On the one hand, the schema of the registry may require modification
    from parliament to parliament. 

    On the other hand, the schema should remain largely consistent
    across parliaments, in order to foster interoperability. For the
    same reason, the schema should take into account ease of integration
    with external systems; i.e. it should be designed to be easy to
    understand from a parliamentary point of view, rather than to make
    sense from an ORM tool's point of view.

The registry should remain synchronised with the data in Plone.

    The data in Plone and the data in the registry should be consistent
    at all times. 

== Design goals for the Plone implementation ==

Bungeni, as a system, is meant to be robust and understandable. 

    . *Easy to run*: It is desirable for IT staff who are not Plone
    specialists to be capable of understanding its workings and of
    maintaining it. Therefore, there should be few points of failure,
    and recovery procedures should be straightforward. The audit log is
    one attempt to fulfil this goal by decoupling Plone from the RDBMS.
    Plone still starts if the RDBMS is unreachable, and audit log forms
    a queue.

    . *Easy to understand*: It should be possible for parliamentary
    officials to understand what data is present in Bungeni, and to
    discuss necessary modifications in as direct and concrete a way as
    possible with the implementers of Bungeni at their parliament.
    Modifications should be clearly documented in such a way that
    parliaments may easily be compared.

    To this end, as much possible of Bungeni is specified using UML. 
    Code is generated from this by ArchGenXML. The code evolves as
    ArchGenXML (and later Genesis) is updated to keep up with changes to
    Plone. This keeps the code consistent even if schemas change.

    Parliament-specific modifications are made in parliament-specific
    UML diagrams, which contain only the modified classes and workflows.

    Representation of schemas and workflows are compact, graphical and
    directly related to the generated code. 

Things should be kept as simple and standard as possible.

    If there is a trade-off, simple and standard is more important than
    custom-built and fast. Rather use some more disk space or CPU time.
    Improve Plone or the other components used, rather than specialising
    Bungeni. Keep Bungeni as plain-Plone as possible, to lower the
    barrier to entry for later contributors, and to gain the maximum
    advantage from books and documentation about Plone.

    To this end, Bungeni is implemented using ArchGenXML-generated
    Archetypes content, together with integrated products (Relations,
    ATVocabularyManager, remember). 

    This goal also motivates keeping the logic in Plone. All
    constraints, validation and business rules can be implemented using
    custom mutators and events (hooks, auditors) in Plone. Expertise in
    the RDBMS used for the registry is not a requirement to troubleshoot
    or maintain Bungeni.

Concerns should be kept separate.

    The Bungeni Plone product should be concerned with modelling a
    parliament in a workable way, and with using Plone mechanisms
    (content types, containment, workflow, roles and groups) to present
    a parliamentary portal. It should not be concerned with the
    registry. In fact, the core functionality of Bungeni is common to
    any consultative body (school boards, town councils, etc.), and it
    would be good if Bungeni could be used in a standalone fashion in
    such bodies, while scaling up to integrate with a registry, XML
    database, OpenOffice editing, a directory for authentication, etc.
    as required. 

    To this end, the Audit Log is implemented as a separate product, and
    Bungeni doesn't need to care about the structure or availability of
    the registry.

== Role of the registry within Plone ==

Bungeni is one user of the registry, among others. The role which the
registry plays within Bungeni is as follows:

Keep object history. 

    It is required to be able to reconstruct the historical state of the
    system, in order to answer queries such as: "Who were the members of
    Committee X on date Y?", or "Show all the ways in which the surname
    of Mr X has been spelt between 1996 and 2000". While Bungeni makes
    use of CMFEditions (and will make use of Plone 3.0 versioning) for
    working documents, this is meant to help users with working
    documents. It is not convenient or efficient to keep track of all
    past object states in Plone.

Allow searching of parliamentary history.

    Livesearch and fulltext search in Bungeni will find current
    documents (including of course the final states, but not the
    intermediate states, of the documents of previous parliaments, that
    remain present in Bungeni). Historical search will allow the
    addition of time constraints, to enable e.g. searching of Document X
    as it was in March, or Document X as it was in October.

Function as data source for integrating additional information.

    As mentioned above, other systems may be populating the registry
    with data not managed by Bungeni. Such information may be shown or
    used within Bungeni if needed.

== The audit log solution ==

In order to satisfy the above design goals, an Audit Log was specified
and implemented. 

It allows separation of concerns.

    Bungeni can use plain Archetypes objects without worrying about how
    changes will get to the registry. 

It removes the registry as a point of failure when writing.

    Transactions written to the audit log will be queued if the registry
    is unavailable.

It eases integration.

    The registry is one consumer of the audit log. The audit log uses
    the standard Python logging module, and so may log to a logfile,
    syslog, email, HTTP, etc. Besides populating the registry,
    consumers of the audit log may:

      * sign and store a transaction record offsite as a security trail,

      * replay transactions into a backup instance of Bungeni, etc.

    It also functions as an integration layer between Bungeni and the
    Registry. The log that is written is complete, but the format
    reflects the names of fields, transitions, etc. within Bungeni. The
    log consumer that updates the Registry maps this format to the
    registry's schema. If the registry schema changes, only this
    consumer needs to be updated.

== Proposed modifications to Bungeni ==

Bungeni's usage of the registry is under discussion. The following
suggestions have been made:

  * Store some of a content type's fields in Plone, and some in the registry.
  * This implies writing directly to the registry, instead of writing to an audit log.
  * Store some kinds of data (e.g. attendance records) in the registry, and use Plone to browse and edit these records.
  * Enforce data integrity using database constraints in the registry, rather than in Plone.

I will address these suggestions in turn, relating them to the goals
outlined.

Store some fields in Plone, and some in the registry.

    * SQLStorage isn't being recommended, and it doesn't look like an improved SQLStorage will be trivial to do. 
    * This closely couples Bungeni to the registry schema: we need to watch out when it changes, and Bungeni may require changes to the schema to accommodate improved SQLStorage.
    * What do we gain from doing this? The data is already going to the registry via the audit log with negligible lag. It seems to me that we're gaining fragility.

Write directly to the registry.

    * This makes the RDBMS a point of failure for Bungeni: if the database isn't available, objects with RDBMS-backed fields won't be available.

Store some kinds of (non-content) data in the registry.

    By all means. If the content doesn't want to be indexed in the site
    catalog, or allow comments, workflow, expose separate page views, be
    placeful, etc. then an RDBMS is an excellent place for it. It
    remains a point of failure in that this content won't be available
    if the registry is not reachable, but the failure should be
    localised (i.e. you can't view attendance records, but you can still
    submit questions, work on committee documents, annotate bills, etc.)

Enforce data integrity using database constraints.

    Of course the registry should enforce constraints. However, I think
    that Bungeni will also need to enforce these constraints if only to
    present a sensible UI: only include valid content in field
    vocabularies, don't show a delete button if deletion won't be
    allowed, etc. I don't think enforcing constraints in Bungeni can
    really be avoided.

    If some fields are stored using the future improved SQLStorage, then
    object edits will fail upon commit, when the RDBMS write fails due
    to violated constraints. However, this pattern is still possible
    using the audit log, using a handler that logs to the registry RDBMS
    instead of to a file. This couples more tightly than logging to a
    file that queues transactions if the registry is unavailable, but
    either is possible.

    The most important consideration, however, is to keep Bungeni's
    logic in Python code, structured in terms of Plone products that use
    Plone mechanisms. 