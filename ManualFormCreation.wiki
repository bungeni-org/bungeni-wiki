#summary Create Form manually and override the built in automatic form generation
#labels zope,sqlalchemy
= Introduction =

For some use cases the autogenerated forms are not sufficient. 



= Details =

depends on what you mean by computed fields.. read only fields on a
form, sure. computed fields in the sense that the value is dynamic
basic on whole object state yes, though the latter would require.

both of these require actually creating a form, not using the
autogenerated facilities. this is pretty easy, though we lack examples
outside of some of the versioning forms. we will have lots more custom
forms in the near future though.

basically subclassing from the appropriate alchemist.ui base classes
to give a form base class, and then using zope.formlib functionality
to customize the form fields. ie say i want a readonly field on edit
form.

{{{
from bungeni.core import interfaces
from alchemist.ui import core
from zope.formlib import form

class ContentEditForm( core.EditForm ):
   form_fields = form.Fields( interface.IMyContent )
   form_fields['name'].for_display= True

    def update(self):
        """
        Called by formlib after __init__ for every page update. This is
        the method you can use to update form fields from your class
        """               
        self.setUpWidgets()

}}}

the name of the view should be the same as the autogenerated view, and
it will override any autogenerated form, any manually created forms
need to also be manually registered in zcml.

To get the name of the autogenerated form you may use echo="True" on the db:catalyst declaration and it will log to the stdout all the things that its doing.
{{{
  <db:catalyst
     class=".domain.GroupSittingAttendance"
     descriptor=".descriptor.AttendanceDescriptor"
     interface_module=".interfaces"
     ui_module="bungeni.ui.content"
     echo="True"
    />  
}}}
will produce the output:
{{{
catalyst domain -> GroupSittingAttendance: generated interface bungeni.core.interfaces.IGroupSittingAttendance
catalyst container -> GroupSittingAttendance: generated container bungeni.core.domain.GroupSittingAttendanceContainer
catalyst container -> GroupSittingAttendance: generated container interface bungeni.core.domain.IGroupSittingAttendanceContainer
catalyst ui -> GroupSittingAttendance: generated add view bungeni.ui.content.GroupSittingAttendanceAddForm
catalyst ui -> GroupSittingAttendance: registered GroupSittingAttendanceAddForm for IGroupSittingAttendanceContainer, layer Default, permission zope.Public
catalyst ui -> GroupSittingAttendance: generated edit view bungeni.ui.content.GroupSittingAttendanceEditForm
catalyst ui -> GroupSittingAttendance: registered GroupSittingAttendanceEditForm for IGroupSittingAttendance, layer Default, permission zope.Public
catalyst ui -> GroupSittingAttendance: generated view view bungeni.ui.content.GroupSittingAttendanceDisplayForm
catalyst ui -> GroupSittingAttendance: registered GroupSittingAttendanceDisplayForm for IGroupSittingAttendance, layer Default, permission zope.Public
}}}


>
>  rational:
>
>  for some checks we need to access the parent, e.g. a parliamentary
>  sitting must be in the date range of the parliament, it cannot start
>  before the parliaments start date and must not end after the parliament
>  end date.

first, this really doesn't have anything to do with computed fields.
second when accessing context its important to understand that their
are two different categories of forms with two different contexts, ie.
add form and edit forms. unlike cmf, zope3 isn't required to create a
content stub just to have a form, but that distinction also means we
have two forms for a content that would need to be potentially
modified to handle these constraints.

second, any formlib form can have a custom validator independent of
any schema invariants, as part of the action handler. see zope.formlib
readme for examples.

third, yes you can use a schema invariant and still have access to
context, but thats only meaningful in certain an edit form context.

a parent is accessed via ob.__parent__


>
>  If i check constraints with invariants i can only access the current
>  fields of the form. afaik there is no way to access the parent of the
>  object i am editing (or is there?).
>
>  the computed field must not be editable and should be hidden by default,
>  though in some use cases it would make sense to display it.
>

use a custom form and omit the field or set it to display mode.